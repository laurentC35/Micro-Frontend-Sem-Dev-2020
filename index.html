<html>

<head>
    <link rel="stylesheet" href="reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="reveal.js/dist/theme/solarized.css">
    <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css">

    <title>MFE - SemDev2020</title>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>
                    S√©minaire dev Insee 2020
                </h2>
                <br />
                <h1>
                    Micro-frontend
                </h1>
                <br />
                <br />
                <div>
                    <p><i>Laurent Caouissin</i></p>
                    <p>
                        <cite>
                            <a href="https://github.com/laurentC35/Micro-Frontend-Sem-Dev-2020">https://github.com/laurentC35/Micro-Frontend-Sem-Dev-2020</a>
                        </cite>
                    </p>
                </div>
            </section>
            <section>
                <section>
                    <h2>
                        Micro-frontend
                    </h2>
                    <br />
                    <h3>
                        techniques de d√©coupage d'application JS
                    </h3>
                </section>
                <section>
                    <h2>
                        Qu'est ce que c'est ?
                    </h2>
                    <br />
                    <p>
                        <b>Les Micro-Frontends reprennent le concept d'architecture des micro-services, et l'applique au d√©veloppement frontal.</b>
                    </p>
                </section>
                <section>
                    <h3>Pourquoi faire ?</h3>
                    <ul>
                        <li>Applications monolithes : difficiles √† g√©rer, maintenir ou moderniser</li>
                        <li>Trouver un moyen de r√©duire les co√ªts</li>
                        <li>Les micro-services sont n√©s dans les "back-office"</li>
                        <li>Les "front-office" reste des monolithes</li>
                    </ul>
                    <h4>=> Cr√©ation des micro-frontend</h4>
                </section>
                <section>
                    <h3>Principes</h3>
                    <ul>
                        <li>Concept architectural</li>
                        <li>Pas de cadre/norme ou d'APIs d√©finis</li>
                        <li>Une seule r√©gle : diviser l'application en plusieurs, chacune ayant son d√©p√¥t, centr√©e sur un lot de fonctionnalit√©s</li>
                    </ul>
                </section>                
                <section>
                    <h4>Pour l'utilisateur final : une seule application</h4>
                    <img src="img/deployment.png">
                </section>
                <section>
                    <h3>Au niveau de l'UI</h3>
                    <img src="img/ui.png">
                </section>
                <section>
                    <h3>Quels sont les avantages de d√©couper ?</h3>
                    <ul>
                        <li>S√©paration des √©quipes de d√©veloppement üëç</li>
                        <li>S√©paration des cycles de vies des applications üëç</li>
                        <li>Choix des versions des frameworks frontend libres pour chacune des sous-appliaction : React, Angular, VueJs üëç</li>
                    </ul>
                </section>
                
            </section>
            <section>
                <section>
                    <h2>Concr√™tement : comment √ßa marche ?</h2>
                    <h4>Plusieurs possibilit√©s avec les t√©chnologies web actuelles</h4>
                    <ul>
                        <li>iframe  ü§Æ</li>
                        <li>Routage serveur</li>
                        <li>Int√©gration au build üòâ</li>
                        <li>Int√©gration au runtime ü•∞</li>
                    </ul>
                </section>
                <section>
                    <h2>Les Web Components & le Shadow Dom</h2>
                    <h5>Int√©gration au runtime</h5>
                    <i><b>"The Dom is the API"</b></i>
                </section>
                <section>
                    <b>Norme W3C</b>
                    <i>"Les Composants Web sont constitu√©s de plusieurs technologies distinctes permettant de cr√©er des composants d'interface graphique personnalis√©s et r√©utilisables, qui ont √©t√© cr√©√©s en utilisant des technologies web libres."</i>
                </section>
                <section>
                    <b>Pour d√©finir le web composant : </b>
                    <pre><code data-trim>
                        class MyNewComponent extends HTMLElement {
                          
                            connectedCallback() {
                                this.innerHTML = <div>My new webComponent</div>
                            }
                          
                            disconnectedCallback() { ... }

                          }
                          
                          window.customElements.define("my-new-webcomponent", MyNewComponent);
                        }
                    </code></pre>
                    <b>Pour utiliser le web composant, il suffit d'ajouter le nouveau tag html</b>
                    <pre><code data-trim>
                        <my-new-webcomponent></my-new-webcomponent>
                    </code></pre>
                </section>
                <section>
                    <h2>Live coding : petite d√©mo</h2>
                </section>
                <section>
                    <h2>Le shadow Dom</h2>
                    <p>Le shadow Dom permet d'encapsuler le JavaScript et le CSS des √©l√©ments HTML cr√©√©s</p>
                    <img src="img/shadow-dom.png">
                </section>
                <section>
                    <h3>Shadow dom</h3>
                    <ul>
                        <li>Permet d'√©viter les interf√©rences entre les fichiers JavaScript</li>
                        <li>Permet donc d'utiliser plusieurs frameworks (ou version de framework) au sein de la m√™me application</li>
                        <li>Permet d'√©viter que les styles des un √©crasent le style des autres</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Besoins Metallica</h2>
                    <h4>Poste de collecte enqu√™teur</h4>
                </section>
                <section>
                    <h2>2 besoins principaux</h2>
                    <ol>
                        <li>Organiser la collecte</li>
                        <li>Collecter de la donn√©es d√©finies via les m√©tadonn√©es</li>
                    </ol>
                </section>
                <section>
                    <h3>1. Organiser la collecte</h3>
                    <ul>
                        <li>Application de gestion</li>
                        <li>Adh√©rent √† l'organisation de l'Insee</li>
                        <li>(cycle de vie des unit√©es enqu√™t√©es, ...)</li>
                    </ul>
                </section>
                <section>
                    <h3>2. Collecter de la donn√©es</h3>
                    <ul>
                        <li>Application g√©n√©rique (d√©finies via les m√©tadonn√©es)</li>
                        <li>Adh√©rent √† la librairie de composants Lunatic</li>
                        <li>Instancie des questionnaires</li>
                        <li>Application r√©utilisable (Pogues visualisation, contr√¥le qualit√© (relecture des donn√©es collect√©es par des agents en bureau))</li>
                    </ul>
                </section>
                <section>
                    <h3>Bilan</h3>
                    <p>On d√©coupe le poste de collecte enqu√™teur en 2 applications</p>
                    <p><b>Cela permet en plus:</b></p>
                    <ul>
                        <li>D'avoir des cycles de vies d'application diff√©rentes</li>
                        <li>Equipe de d√©veloppement/maintenance s√©par√©es</li>
                    </ul>
                </section>
                <section>
                    <h2>D√©monstration</h2>
                    <a href="https://collecte-enqueteurs.enquetes.recette2.insee.fr" target="_blank">Pearl</a> <br/>
                    <a href="https://questionnaire-enqueteurs.enquetes.recette2.insee.fr" target="_blank">Queen</a>
                    <br />
                    <p><b>Sur le cloud :</b></p>
                    <p>Pearl : <a href="https://pearl.demo.dev.sspcloud.fr">https://pearl.demo.dev.sspcloud.fr</a> <br/>
                       Queen : <a href="https://queen.demo.dev.sspcloud.fr">https://queen.demo.dev.sspcloud.fr</a></p>
                </section>
                <section>
                    <img src="img/archi.png">
                </section>
                <section>
                    <h2>Probl√©matique</h2>
                    <ul>
                        <li>L'authentification au sein des deux applications</li>
                        <li>Communications entre les applications</li>
                        <li>Les CORS üò≠</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Bonus : Micro-frontend x PWA</h2>
                Le poste de collecte doit fonctionner hors ligne. <br/>
                Nous avons donc mixer les deux technologies (assez simplement üòÅ)
                </section>
                <section>
                    <h2>Rappel PWA</h2>
                    Les PWA sont des applications pouvant fonctionner hors ligne gr√¢ce aux service-worker.<br/>
                    <br/> 
                    Il "suffit" donc de combiner les service-worker des deux applications !
                    <pre><code data-trim>
                        /* Dans l'application principale */
                        const swUrl = `${window.location.origin}/service-worker-custom.js?QUEEN_URL=${config.QUEEN_URL}`
                        navigator.serviceWorker.register(swUrl)

                        /* dans le service-worker-custom.js de l'application */                        
                        self._QUEEN_URL = new URL(location).searchParams.get('QUEEN_URL');
                        importScripts('/service-worker.js', `${self._QUEEN_URL}/queen-service-worker.js`);
                    </code></pre>
                </section>
                
            </section>
            <section>
                <h2>Source</h2>
                <ul>
                    <li><a href="https://dev.to/phodal/micro-frontend-architecture-in-action-4n60">6 implementations possibles de microFrontend</a></li>
                    <li><a href="https://medium.com/javascript-in-plain-english/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a">Exemple React / angular</a></li>
                    <li><a href="https://medium.com/stepstone-tech/microfrontends-part-2-integration-and-communication-3385bc242673">Communications inter micro-frontent</a></li>
                </ul>
            </section>
            <section>
                <h2>Merci de votre attention</h2>
                <br />
                <br />
                <br />
                <h2>Questions ?</h2>
            </section>
        </div>
    </div>
    <script src="reveal.js/dist/reveal.js"></script>
    <script src="reveal.js/plugin/highlight/highlight.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            transition: 'slide',
            plugins: [ RevealHighlight ]
        });
    </script>
</body>

</html>